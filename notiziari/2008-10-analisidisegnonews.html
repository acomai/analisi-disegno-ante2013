 
<html>
<head>
<title>analisi-disegno.com - news 2008-10-15</title>
<link rel="stylesheet" type="text/css" 
		href="/analisi-disegno.css" />
</head>

<body bgcolor="#FFFFFF">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
  <tr> 
    <!--msnavigation-->
<table border="0" cellpadding="0" cellspacing="0" width="100%"><tr>
    <td> <!-- #BeginLibraryItem "/Library/Top.lbi" -->
<p style=text-align:center><big><font color="#800000"><big><strong>analisi-disegno.com</strong></big></font></big></p>
<p style="background-color:#FFFF00;text-align:center" ><font face="Arial"><font color="#800000"><b><font color="#000000"><a href="../">Homepage</a></font> 
  </b></font></font>&nbsp;<font face="Arial"><font color="#800000"><b>|</b></font></font> 
  <font face="Arial"><a href="/notiziario.html" target="_blank">Notiziario</a><font color="#800000"><b>&nbsp;|</b></font></font> 
  <b><a href="/welcome_e.html">In 
  English</a></b></p>
      <hr>
<!-- #EndLibraryItem --><!--msnavigation--></table><!--msnavigation-->
<p align="center"><big><font face="Arial" color="#800000"><strong></strong></font></big></p>
      </td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
  <tr> 
    <td valign="top"> 
      <h1>analisi-disegno.news - 15 ottobre 2008</h1>
      <h2>Documentare l'architettura software</h2>
      <p>L'architettura di un sistema software ci dice come &egrave; fatto il sistema:</p>
		<ul>
        <li>Il contesto (ambiente esterno) in cui si colloca, e le interfacce tra il sistema e il resto del mondo. </li>
        <li>L'organizzazione interna del sistema in &quot;parti&quot;, e le modalit&agrave; 
        con cui tali &quot;parti&quot; interagiscono tra loro.</li>
        <li>Le tecnologie utilizzate per l'implementazione e l'esecuzione delle &quot;parti&quot;.</li>
		</ul>
      <p>Mentre si sviluppa, condividere l'architettura agevola la comunicazione tra i partecipanti al progetto, soprattutto quando le persone operano 
        in luoghi diversi, o quando intervengono nel progetto in momenti successivi, o quando si collabora tra entit&agrave; diverse, in un rapporto
        cliente - fornitore.</p>
      <p>Per un sistema gi&agrave; esistente, se non abbiamo altre fonti disponibili,
        l'architettura software &egrave; rilevabile dal codice. Ma &egrave; necessaria 
        molta fatica per scoprirla.</p>
      <p>Meglio avere una qualche forma di documentazione. Una buona documentazione architetturale permette di capire un&#146;applicazione
        esistente pi&ugrave; in fretta; e ci&ograve; vale sia quando dobbiamo 
        studiare
        un&#146;applicazione realizzata da altri, sia quando dobbiamo rimettere 
        le
        mani su una che abbiamo realizzato noi stessi in passato.</p>
      <p>Quali sono le caratteristiche 
        di una &quot;buona&quot; documentazione
        architetturale? La sintesi, la chiarezza e l'aggiornamento.</p>
      <h2>La sintesi</h2>
	  <p>
        L'architettura va rappresentata nel modo pi&ugrave; semplice ed essenziale. 
        Con
        pochi diagrammi e con descrizioni testuali stringate.</p>
        <p>La rappresentazione dell'architettura deve fornire una visione di
        insieme del sistema, della sua struttura, delle interazioni tra le sue
        parti. Senza dettagli, se non per zoomare su aspetti particolari che &egrave;
        necessario evidenziare a chi dovr&agrave; prendere in carico il sistema.
        Pi&ugrave; la documentazione dell'architettura &egrave; dettagliata, pi&ugrave; 
        diventa
        difficile che sia chiara ed aggiornata. Meglio che sia sintetica.</p>
      <h2>La chiarezza</h2>
        <p>Quando documentiamo, il nostro obiettivo deve essere quello di
        comunicare efficacemente. Per fortuna esiste una notazione standard -
        UML, lo Unified Modeling Language - per rappresentare le architetture
        software. Ma bisogna usarla bene.</p>
        <p>Quando si schizza un diagramma per ragionare su un problema, la nostra
        attenzione &egrave; concentrata sul problema, non sul diagramma.</p>
        <p>Quando si documenta, invece, dobbiamo fare tutto ci&ograve; che si pu&ograve; 
        per
        farci capire. Ci&ograve; significa, ad esempio, creare diagrammi leggibili;
        evitare l'uso di costrutti UML poco comuni, noti solo agli esperti; non
        cercare di esplicitare tutto in forma grafica: se &egrave; vero che un'immagine
        vale mille parole, qualche parola di commento associata alle immagini
        pu&ograve; semplificare diagrammi che altrimenti risulterebbero troppo
        sofisticati e complessi.</p>
      <h2>L'aggiornamento</h2>
        <p>In parecchie organizzazioni, &egrave; raro trovare documentazione aggiornata.
        Ma l'invecchiamento (della documentazione) pu&ograve; essere ritardato 
        o
        evitato. Quando i documenti architetturali sono sintetici, &egrave; pi&ugrave;
        difficile che vengano resi obsoleti da modifiche marginali al sistema. 
        E
        se la documentazione architetturale viene consolidata quando si &egrave;
        completata la nuova versione del sistema, just-in-time, il
        disallineamento non ha ragione di esistere.</p>
        <p>Aggiornare la documentazione dell&#146;architettura software pu&ograve; 
        non essere
        troppo oneroso, se si segue un approccio minimalista, documentando solo
        le scelte fondamentali, senza scendere in dettaglio su ogni aspetto
        della progettazione.</p>
      
      <p><font face="Arial, Helvetica, sans-serif">****************************************************************</p>
        <h2>Segnalazioni</h2>
      <p>*** <b>I requisiti si scoprono 
        meglio dopo</b> *****************</p>
      <p>La situazione ideale, si sa, 
        &egrave; quella in cui i requisiti vengono chiariti all'inizio di un progetto. Ma per quanto ci sforziamo di
        riuscirci, e anche se ci avvaliamo delle tecniche pi&ugrave; efficaci 
        per
        farlo, sappiamo che spesso non &egrave; possibile.</p>
      <p>Esprimere requisiti per un 
        sistema che esiste gi&agrave; &egrave; molto pi&ugrave; facile che
        esprimerli per uno che non esiste ancora.
        Vedi il sistema, lo usi, capisci quello che non funziona, quello che
        manca, quello che si potrebbe, vorrebbe, dovrebbe migliorare.
        Molto pi&ugrave; facile che rispondere a domande su come si vorr&agrave; 
        qualcosa che
        non esiste ancora, o sulla correttezza di un modello, o di una specifica.</p>
      <p>&Egrave; un assunto di semplice 
        buon senso. Naturalmente, bisogna vedere come
        trarne le conseguenze in un contesto di sviluppo professionale, con
        relazioni cliente-fornitore, contratti, ecc.</p>
      <p>Su questo, un <a href="http://martinfowler.com/bliki/ObservedRequirement.html" target="_blank">articolo 
        interessante di Martin Fowler</a>.</p>
      <p>&nbsp;</p>
      <p>*** <b>Precisare i requisiti</b> 
        *******************************</p>
      <p>Un intervento di Tom Gilb su 
        Requirements Network:
        &quot;Requirements Relationships: A Theory, some Principles, and a Practical
        Approach&quot;</p>
      <p>Tom Gilb &egrave; uno dei padri 
        dell'approccio iterativo e incrementale, con il
        metodo Evo (1988).
        Per quanto riguarda la gestione dei requisiti, il suo contributo
        fondamentale &egrave; stato l'introduzione di Planguage, un linguaggio 
        per
        precisare i requisiti.</p>
      <p><a href="http://www.requirementsnetwork.com/" target="_blank">Requirements 
        Network</a> &egrave; un sito che pubblica settimanalmente articoli
        sulla gestione requisiti. Bisogna registrarsi con user e password per
        accedere, scaricare articoli, commentare, intervenire.</p>
      <p>&nbsp;</p>
      <p>*** <b>MoSCoW e priorit&agrave;</b> 
        ***********************************</p>
      <p>Il primo corso a cui partecipai 
        sull'analisi dei sistemi - parecchi anni
        fa - insegnava ad usare per i requisiti una classificazione MoSCoW.</p>
      <p>MoSCoW &egrave; un acronimo 
        che sta per:</p>
		<ul>
        <li>Must have - si deve avere</li>
        <li>Should have - si dovrebbe avere</li>
        <li>Could have - si potrebbe avere</li>
        <li>Won't have - non si deve avere</li>
		</ul>
      <p>Non ho mai usato la classificazione 
        MoSCoW, anche se suggestiva. E non
        l'ho mai insegnata nei miei corsi. Ho sempre usato la tecnica di
        classificare i requisiti in termini di priorit&agrave;, che ritenevo pi&ugrave; 
        efficace.</p>
      <p>Ma non avevo ragionato a fondo 
        sulla classificazione MoSCoW. L'ha fatto
        invece <a href="http://jamesshore.com/Blog/Coulda-Shoulda-Woulda.html" target="_blank">James 
        Shore</a>.</p>
      <p>&nbsp;</p>
      <p>*** <b>Story Maps</b> ******************************************</p>
      <p>Rappresentare le funzionalit&agrave; 
        di un sistema in un modo comprensibile sia
        agli stakeholders che agli sviluppatori. E inoltre utile per indicare 
        le
        priorit&agrave;.</p>
      <p>La tecnica delle &quot;story 
        maps&quot; &egrave; semplice. Jeff Patton la descrive in
        <a href="http://www.agileproductdesign.com/blog/the_new_backlog.html" target="_blank">questo 
        intervento</a>.</p>
      <p>&nbsp;</p>
      <p>*** <b>Software perfetto</b> 
        *************************</p>
      <p>&quot;<a href="http://www.amazon.com/Perfect-Software-Other-Illusions-Testing/dp/0932633692/" target="_blank">Perfect 
        Software and other illusions about testing</a>&quot;. &Egrave; un libro 
        di
        Gerald Weinberg, uscito da poco.</p>
      <p>Tra tutte le attivit&agrave; 
        collegate al software, il testing &egrave; l'attivit&agrave; pi&ugrave;
        fraintesa. Anche dai professionisti dello sviluppo.</p>
      <p>Il libriccino &egrave; sottile, 
        scritto bene, si legge in fretta, non entra in
        dettagli tecnici. Un'ottima introduzione alla realt&agrave; del testing, 
        per
        chiunque lavori in un progetto, per i manager, per i committenti. Anche
        per chi di software sa poco o nulla.</p>
      <p>********************************************************************</p>
      <p>Se volete, potete contribuire 
        ad ANALISI-DISEGNO:</p>
		<ul>
        <li>comunicando segnalazioni e commenti a <a href="mailto:adriano.comai@analisi-disegno.com">adriano.comai@analisi-disegno.com</a></li>
        <li>facendolo conoscere ad altre persone a cui possa interessare</li>
		</ul>
      <p>********************************************************************</p>
      <p>ANALISI-DISEGNO - (c) Adriano 
        Comai </p>
      <p>ANALISI-DISEGNO viene spedito 
        a chi ne fa <a href="../notiziario.html">richiesta</a>. La pubblicazione
        non avviene con periodicit&agrave; predefinita.</p>
      <p>********************************************************************</p>
      <p><a href="../notiziario.html">Archivio notiziari</a> 
        | <a href="2008-09-analisidisegnonews.html">Notiziario precedente</a> | <a href="2008-11-analisidisegnonews.html">Notiziario successivo</a></p>
      </td>
  </tr>
</table>
<!-- #BeginLibraryItem "/Library/Bottom.lbi" --><hr>
<p style=text-align:center><font face="Arial"><a href="../">analisi-disegno.com</a>, 
  servizi e materiali per lo sviluppo dei sistemi software, a cura di <a href="../a_comai/adriano_comai.htm">Adriano 
  Comai</a>. </font></p>
<!-- #EndLibraryItem -->
</body>
</html>

